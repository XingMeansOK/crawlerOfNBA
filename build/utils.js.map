{"version":3,"sources":["../src/utils.js"],"names":["playerID","Promise","resolve","reject","url","req","http","get","res","statusCode","contentType","headers","isDocument","test","error","Error","console","message","resume","setEncoding","rawData","on","chunk","info","$","load","prior","html","push","e","playerRequest","sendRequest","xhr","XMLHttpRequest","responseType","open","onreadystatechange","readyState","DONE","status","response","statusText","setRequestHeader","send","require","NodeRequest","isJson","parsedData","JSON","parse"],"mappings":"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","file":"utils.js","sourcesContent":["import cheerio from 'cheerio'\r\n\r\n/*\r\n  前端异步请求\r\n  @param url 请求地址\r\n  发送get请求\r\n  返回一个Promise对象\r\n  当请求返回结果的时候，promise状态改变\r\n*/\r\nfunction sendRequest( url ) {\r\n  return new Promise( ( resolve, reject ) => {\r\n    var xhr = new XMLHttpRequest();\r\n    // 设置为'json'后，xhr.response的数据类型就是一个js对象\r\n    xhr.responseType = 'json';\r\n\r\n    // 请求方式， 请求地址， 是否异步\r\n    xhr.open( 'GET', url, true );\r\n\r\n    // 状态改变的处理函数\r\n    xhr.onreadystatechange = () => { // 或者使用 onload\r\n\r\n      if( xhr.readyState !== XMLHttpRequest.DONE ) return;\r\n\r\n      // 当请求已经完成\r\n      if( xhr.status === 200 ) {\r\n        resolve( xhr.response );\r\n      } else {\r\n        reject( new Error( xhr.statusText ) );\r\n      }\r\n    }\r\n\r\n    // 必须在open之后，send之前调用,（第一个参数大小写不敏感）\r\n    // 指定客户端能够接受的数据类型为json数据\r\n    xhr.setRequestHeader( 'Accept', 'application/json' );\r\n\r\n    // 发送请求\r\n    xhr.send();\r\n\r\n  } )\r\n}\r\n\r\nconst http = require( 'http' ); // 不用安装，直接用就行，node的核心模块\r\n\r\n/*\r\n  node程序发送get请求，获取.JSON文件\r\n  返回一个promise对象\r\n  @param url string 请求地址\r\n*/\r\nfunction NodeRequest( url ) {\r\n  return new Promise( ( resolve, reject ) => {\r\n\r\n    // http.get和http.request返回的都是http.ClientRequest类型的对象实例，表示一个进行中的请求\r\n    // get是request的简化，使用GET请求，并且不需要调用http.ClientRequest.end\r\n    // 当请求对象收到响应头时发出‘response’事件，意味着将要开始接收响应数据。第二个参数是这个事件的处理函数。此事件只发出一次。\r\n    let req = http.get( url, ( res ) => {\r\n\r\n      // response事件处理函数的参数是IncomingMessage的对象实例，可以用于访问响应状态、头和数据\r\n\r\n      const { statusCode } = res;\r\n      const contentType = res.headers[ 'content-type' ];\r\n      const isJson = /^application\\/json/.test(contentType);\r\n\r\n      let error;\r\n\r\n      // 如果请求没有成功\r\n      if ( statusCode !== 200 ) {\r\n        error = new Error('Request Failed.\\n' +\r\n                          `Status Code: ${statusCode}`);\r\n      } else if ( !isJson ) {\r\n\r\n        // 如果返回的数据类型不是json数据\r\n        error = new Error('Invalid content-type.\\n' +\r\n                          `Expected application/json but received ${contentType}`);\r\n      }\r\n\r\n      if ( error ) {\r\n        console.error(error.message);\r\n\r\n        // 如果出现了错误，重新开始？\r\n        // consume response data to free up memory\r\n        res.resume();\r\n        reject( error );\r\n        return;\r\n      }\r\n\r\n      res.setEncoding('utf8');\r\n      let rawData = '';\r\n\r\n      // 当一个数据块到达的时候触发。chunk代表一个数据块。一个响应可能有多个数据块\r\n      res.on( 'data', ( chunk ) => {\r\n        rawData += chunk;\r\n      } );\r\n\r\n      // 当所有的数据块都接收完毕才会调用\r\n      res.on('end', () => {\r\n        try {\r\n          const parsedData = JSON.parse(rawData);\r\n          // promise状态改变\r\n          resolve( parsedData ); // 将获取到的json数据转换成js对象后，将作为await的返回值\r\n        } catch (e) {\r\n          console.error(e.message);\r\n          reject( e.message );\r\n        }\r\n      });\r\n\r\n    })\r\n\r\n    req.on('error', (e) => {\r\n      console.error(`Got error: ${e.message}`);\r\n    });\r\n\r\n  } )\r\n}\r\n\r\n/*\r\n  获取单个球员的信息\r\n  @param playerID number\r\n  @return Array 球员的补充信息\r\n*/\r\nasync function playerRequest( playerID ) {\r\n\r\n  return new Promise( ( resolve, reject ) => {\r\n\r\n    var url = `http://stats.nba.com/player/${playerID}`\r\n\r\n    // 请求对象接收到响应头的时候触发response事件，第二个参数是这个事件的处理函数\r\n    let req = http.get( url, ( res ) => {\r\n\r\n      // response事件处理函数的参数是IncomingMessage的对象实例，可以用于访问响应状态、头和数据\r\n\r\n      const { statusCode } = res;\r\n      const contentType = res.headers[ 'content-type' ];\r\n      const isDocument = /^text\\/html/.test(contentType);\r\n\r\n      let error;\r\n\r\n      // 如果请求没有成功\r\n      if ( statusCode !== 200 ) {\r\n        error = new Error('Request Failed.\\n' +\r\n                          `Status Code: ${statusCode}`);\r\n      } else if ( !isDocument ) {\r\n\r\n        // 如果返回的数据类型不是text/html数据\r\n        error = new Error('Invalid content-type.\\n' +\r\n                          `Expected text/html but received ${contentType}`);\r\n      }\r\n\r\n      if ( error ) {\r\n        console.error(error.message);\r\n\r\n        // 如果出现了错误，重新开始？\r\n        // consume response data to free up memory\r\n        res.resume();\r\n        reject( error );\r\n        return;\r\n      }\r\n\r\n      res.setEncoding('utf8');\r\n      let rawData = '';\r\n\r\n      // 当一个数据块到达的时候触发。chunk代表一个数据块。一个响应可能有多个数据块\r\n      res.on( 'data', ( chunk ) => {\r\n        rawData += chunk;\r\n      } );\r\n\r\n      // 当所有的数据块都接收完毕才会调用\r\n      res.on('end', () => {\r\n        try {\r\n\r\n          // 补充的信息存放在这里\r\n          let info = [];\r\n          // 将请求得到的html解析成dom\r\n          let $ = cheerio.load( rawData );\r\n          // 国籍\r\n          let prior = $( '.player-stats__prior .player-stats__stat-value' ).html();\r\n          // 获取基本信息。依次是：\r\n          info.push( prior );\r\n\r\n          // 释放内存，垃圾回收\r\n          rawData = null;\r\n\r\n          resolve( info );\r\n\r\n        } catch (e) {\r\n          console.error(e.message);\r\n          reject( e.message );\r\n        }\r\n      });\r\n\r\n    })\r\n\r\n    req.on('error', (e) => {\r\n      console.error(`Got error: ${e.message}`);\r\n    });\r\n\r\n  } )\r\n}\r\n\r\nexport { sendRequest, NodeRequest, playerRequest };\r\n"]}