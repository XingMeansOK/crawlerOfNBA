{"version":3,"sources":["../src/index.js"],"names":["player","additionInfo","push","count","console","log","complementPlayerInfo","concurrency","progressControllar","main","players","data","Promise","resolve","reject","completed","requesting","started","replenish","length","then"],"mappings":";;;;;;AASA;;;;;wEAIA,iBAAqCA,MAArC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAG2B,0BAAeA,OAAO,CAAP,CAAf,CAH3B;;AAAA;AAGMC,wBAHN;;AAIE;AACAD,mBAAOE,IAAP,kCAAgBD,YAAhB;AACAE;AACAC,oBAAQC,GAAR,CAAaJ,aAAc,CAAd,IAAoB,IAApB,GAA2BE,KAAxC;;AAPF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeG,oB;;;;;AAWf;;;;;;AAkDA;;yEACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEE;AACMC,uBAHR,GAGsB,CAHtB;AAAA;AAAA,mBAIQC,mBAAoBD,WAApB,CAJR;;AAAA;;AAMEH,oBAAQC,GAAR,CAAa,MAAb;;AANF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeI,I;;;;;AA1Ef;;AACA;;;;;;2cAFA;;;AAIA;AACA,IAAIN,QAAQ,CAAZ;AACA;AACA,IAAIO,UAAU,iBAAWC,IAAX,CAAgBD,OAA9B,CAqBA,SAASF,kBAAT,CAA6BD,WAA7B,EAA2C;;AAEzC;AACA,SAAO,IAAIK,OAAJ,CAAa,UAAEC,OAAF,EAAWC,MAAX,EAAuB;;AAEzC,QAAIC,YAAY,CAAhB,CAFyC,CAEtB;AACnB,QAAIC,aAAa,CAAjB,CAHyC,CAGrB;AACpB,QAAIC,UAAU,CAAd,CAJyC,CAIxB;;AAEjB;AACA,KAAE,SAASC,SAAT,GAAqB;;AAErB,UAAIH,aAAaL,QAAQS,MAAzB,EAAkC;AAChC;AACAN;AACA;AACD;;AAED;AACA,aAAOI,UAAUP,QAAQS,MAAlB,IAA4BH,aAAaT,WAAhD,EAA8D;;AAE5DU;AACAD;;AAEAZ,gBAAQC,GAAR,CAAa,iBAAiBW,UAA9B;;AAEA;AACAV,6BAAsBI,QAASO,UAAU,CAAnB,CAAtB,EAA+CG,IAA/C,CAAqD,YAAM;;AAEzD;AACAL;AACAC;;AAEA;AACAE;AACA;AAED,SAVD;AAYD;AAEF,KA/BD;AAgCD,GAvCM,CAAP;AAyCD;;AAaDT","file":"index.js","sourcesContent":["// import 'babel-polyfill'\r\nimport { playerRequest } from './utils'\r\nimport { stats_ptsd } from './data.js'\r\n\r\n// 成功的请求数量\r\nvar count = 0;\r\n// 球员列表（数组）\r\nvar players = stats_ptsd.data.players;\r\n\r\n/*\r\n  @param player Array 数组，数组的每一个元素都是运动员的信息\r\n  补全运动员的信息\r\n*/\r\nasync function complementPlayerInfo( player ) {\r\n\r\n  // 获取运动员的补充信息\r\n  let additionInfo = await playerRequest( player[0] );\r\n  // 将补充信息合并到该运动员数组中（每个运动员用一个数组表示）\r\n  player.push( ...additionInfo );\r\n  count++;\r\n  console.log( additionInfo[ 0 ] + ', ' + count );\r\n\r\n}\r\n\r\n/*\r\n  控制并发\r\n  @param int concurrency 并发的请求数\r\n*/\r\nfunction progressControllar( concurrency ) {\r\n\r\n  // 当所有的请求都结束的时候，返回的这个promise对象resolve\r\n  return new Promise( ( resolve, reject ) => {\r\n\r\n    var completed = 0; // 已经完成的个数\r\n    var requesting = 0; // 正在执行的请求个数\r\n    var started = 0; // 发出的请求个数\r\n\r\n    // replenish是再充满的意思\r\n    ( function replenish() {\r\n\r\n      if( completed >= players.length ) {\r\n        // 当所有的请求都结束\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      // 已经发出的请求个数小于请求总数 && 正在执行的请求个数小于并发最大值\r\n      while( started < players.length && requesting < concurrency ) {\r\n\r\n        started++;\r\n        requesting++;\r\n\r\n        console.log( 'requesting: ' + requesting );\r\n\r\n        // complementPlayerInfo会返回一个Promise\r\n        complementPlayerInfo( players[ started - 1 ] ).then( () => {\r\n\r\n          // 当一个请求完全执行结束之后\r\n          completed++;\r\n          requesting--;\r\n\r\n          // 不要停！保持执行中的请求和并发个数一致\r\n          replenish();\r\n          // setTimeout( 'replenish()', 500 );\r\n\r\n        } )\r\n\r\n      }\r\n\r\n    } )()\r\n  } )\r\n\r\n}\r\n\r\n// 并发执行抓取\r\nasync function main() {\r\n\r\n  // 允许的最大并发数\r\n  const concurrency = 5;\r\n  await progressControllar( concurrency );\r\n\r\n  console.log( 'done' );\r\n\r\n}\r\n\r\nmain();\r\n"]}